PART A â€” EXACT GREEK FORMULAS & UPDATE RULES
(what the system must do, unambiguously)
This is model-level truth. Your agents must not improvise here.
________________________________________
A1 Core assumptions (lock these first)
These are non-negotiable defaults unless you explicitly change them later.
â€¢	Model: Blackâ€“Scholes (European options)
â€¢	Underlying price (S):
â†’ WebSocket LTP of underlying (index / stock)
â€¢	Option price (C / P):
â†’ mid-price = (best_bid + best_ask) / 2
â€¢	Strike (K): REST instrument master
â€¢	Time to expiry (T):
â€¢	T = (expiry_datetime - current_datetime) / 365
â€¢	Risk-free rate (r):
â†’ Static config (e.g. 6.5% or 0.065)
â€¢	Volatility (Ïƒ):
â†’ Implied volatility (derived, not fixed)
________________________________________
A2 Blackâ€“Scholes primitives
d1 and d2 (foundation)
d1 = [ ln(S / K) + (r + 0.5 ÏƒÂ²) T ] / (Ïƒ âˆšT)
d2 = d1 âˆ’ Ïƒ âˆšT
Where:
â€¢	ln = natural log
â€¢	âˆš = square root
________________________________________
A3 Option price formulas (for IV solving)
Call price
C = SÂ·N(d1) âˆ’ KÂ·e^(âˆ’rT)Â·N(d2)
Put price
P = KÂ·e^(âˆ’rT)Â·N(âˆ’d2) âˆ’ SÂ·N(âˆ’d1)
N(x) = standard normal CDF
________________________________________
A4 Implied Volatility (MANDATORY)
Rule
IV must be solved numerically from market price
Use:
â€¢	Newtonâ€“Raphson (preferred)
â€¢	OR bisection fallback (safe)
Inputs:
â€¢	market option price (mid-price)
â€¢	S, K, r, T
Bounds:
Ïƒ_min = 0.01   (1%)
Ïƒ_max = 3.00   (300%)
Stop conditions:
â€¢	price error < â‚¹0.01
â€¢	OR max 50 iterations
âš ï¸ If IV does not converge:
â€¢	mark Greeks as LOW confidence
â€¢	reuse last stable IV
________________________________________
A5 Greek formulas (FINAL, USE EXACTLY)
Let Ï†(x) = standard normal PDF.
________________________________________
âœ… Delta
Call
Î”_call = N(d1)
Put
Î”_put = N(d1) âˆ’ 1
________________________________________
âœ… Gamma (same for call & put)
Î“ = Ï†(d1) / (S Ïƒ âˆšT)
________________________________________
âœ… Theta (per DAY, not per year)
Call
Î˜_call = [
 âˆ’ (S Ï†(d1) Ïƒ) / (2 âˆšT)
 âˆ’ r K e^(âˆ’rT) N(d2)
] / 365
Put
Î˜_put = [
 âˆ’ (S Ï†(d1) Ïƒ) / (2 âˆšT)
 + r K e^(âˆ’rT) N(âˆ’d2)
] / 365
________________________________________
âœ… Vega (per 1% volatility change)
Vega = S Ï†(d1) âˆšT / 100
________________________________________
A6 Greeks update rules (THIS IS CRITICAL)
Your system must not recompute Greeks blindly.
Greeks recompute ONLY when:
â€¢	underlying price changes
â€¢	option bid/ask changes
â€¢	time-to-expiry crosses a minute boundary
â€¢	IV changes beyond tolerance (e.g. 0.1%)
________________________________________
Greeks MUST NOT recompute when:
â€¢	margin API refresh happens
â€¢	fallback REST price is used
â€¢	data confidence is LOW
â€¢	WebSocket feed is stale
________________________________________
A7 Greek confidence tagging (MANDATORY)
Every Greek output must include:
greek_confidence âˆˆ { HIGH, MEDIUM, LOW }
Rules:
â€¢	HIGH
o	WS live
o	IV converged
o	bidâ€“ask spread reasonable
â€¢	MEDIUM
o	WS live
o	IV reused from cache
â€¢	LOW
o	fallback price
o	IV failed
o	stale ticks
âš ï¸ Algos must read this flag.





PART B â€” PROMPTS FOR YOUR AI AGENT TEAM
(copyâ€“paste safe)
You asked for agent prompts â€” here they are, structured and precise.
________________________________________
ðŸ”¹ PROMPT 1 â€” Greeks Engine Agent
You are implementing the Greeks computation engine.

STRICT RULES:
- Use Blackâ€“Scholes European formulas only.
- Do NOT modify SPAN or margin logic.
- Greeks are analytical outputs, not execution inputs.

IMPLEMENT:
1. Compute d1, d2 exactly as defined.
2. Solve implied volatility from option mid-price using:
   - Newtonâ€“Raphson with bisection fallback.
3. Compute Delta, Gamma, Theta (per day), Vega (per 1% vol).
4. Attach Greeks to OptionPriceStore[token].

UPDATE RULES:
- Recompute Greeks only on:
  price change, underlying change, or time decay.
- Freeze Greeks if WebSocket feed is down.
- Never compute Greeks from REST fallback prices.

OUTPUT FORMAT:
{
  delta,
  gamma,
  theta,
  vega,
  iv,
  greek_confidence,
  last_updated_timestamp
}
________________________________________
ðŸ”¹ PROMPT 2 â€” Data Integrity & Confidence Agent
You are responsible for Greek confidence and data integrity.

IMPLEMENT:
- Confidence tagging: HIGH / MEDIUM / LOW.
- Monitor WebSocket tick freshness.
- Mark Greeks LOW confidence if:
  - tick gap > threshold
  - IV fails to converge
  - fallback feed active

DO NOT:
- Smooth Greeks aggressively.
- Interpolate across missing ticks.
- Average across instruments.

Ensure:
- Algos can query greek_confidence.
- UI displays confidence state visibly.
________________________________________
ðŸ”¹ PROMPT 3 â€” Algo Safety Agent
You enforce safe algorithm behavior using Greeks.

RULES:
- Algorithms must NOT place trades if greek_confidence = LOW.
- Greeks must be used only for:
  strategy selection, hedging logic, risk analysis.
- Margin decisions remain REST-authoritative.

IMPLEMENT:
- Pre-trade checks using bid/ask + Greeks.
- Kill-switch if Greeks freeze or confidence drops.
________________________________________
ðŸ”¹ PROMPT 4 â€” Performance & Stability Agent
You optimize performance without altering math.

GOALS:
- Avoid recomputing Greeks per tick unnecessarily.
- Cache IV per instrument.
- Trigger recompute only on meaningful price moves.

ENSURE:
- No memory leaks.
- No blocking calls in WebSocket thread.
- Greek computation isolated from order execution.
________________________________________
FINAL LOCK-IN STATEMENT (IMPORTANT)
If your agents implement exactly whatâ€™s above:
â€¢	Greeks will match real broker terminals
â€¢	Algo behavior will survive live deployment
â€¢	No false PnL due to math shortcuts
â€¢	SPAN integrity remains intact
This is institution-grade correctness, not hobby logic.

